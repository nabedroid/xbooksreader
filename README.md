# 概要

# TODO
- フォルダ表示で検索対象とするフォルダの追加機能
- 本棚のブックボタンの立体感改善

# 開発メモ


## ソリューションとプロジェクト
イメージとしては、ソリューション（商品）を作るためのプロジェクト（部品）という関係。

## Windows コンソールアプリ
GUIを使用せずに裏方で動くようなアプリケーション。

### コマンドプロンプトを非表示する
リンカのオプションの`SUBSYSTEM`を変更する必要がある。
世間では以下のように変更すると記載がある（[参考](https://qiita.com/awrznc/items/8faea4db2fa1be683d70)）。

1. ソリューションエクスプローラーからプロジェクトを右クリックし`プロパティ`を選択 or メニューバーから`プロジェクト` > `プロジェクトのプロパティ`を選択
2. `構成プロパティ`を選択
3. `リンカー`を選択
4. `システム`を選択
5. `サブシステム`を選択
6. `サブシステム`の値を`コンソール...`から`Windows...`に変更

ただ、`Visual Studio 2022`になってから設定方法が変わったのか、上記手順では変更できなかったので、下記の手順で変更した。

1. ソリューションエクスプローラーからプロジェクトを右クリックし`プロパティ`を選択 or メニューバーから`プロジェクト` > `プロジェクトのプロパティ`を選択
2. `アプリケーション`を選択
3. `出力の種類`を選択
4. `出力の種類`の値を`コンソール アプリケーション`から`Windows アプリケーション`に変更

## ライブラリを追加する場合

### 組み込み済みのライブラリの場合
- **ソリューションエクスプローラー**からプロジェクトを選択
- `参照`を右クリック
- `参照の追加`を選択
- `アセンブリ`を選択
- 必要なライブラリのチェックボックスを有効化

### それ以外の場合
- **ソリューションエクスプローラー**からプロジェクトを右クリック
- `NuGetパッケージの管理`を選択
- 必要なライブラリを検索しインストール

### 他プロジェクトの場合
- **ソリューションエクスプローラー**からプロジェクトを選択
- `参照`を右クリック
- `参照の追加`を選択
- `プロジェクト`を選択
- 必要なプロジェクトのチェックボックスを有効化

## 画像ファイルをBase64に変換するコード

```C#
Bitmap bitmap = new Bitmap("C:\\work\\html\\iitclogviwer\\images\\CtrlKobe\\ENLIGHTENED.png");
ImageConverter converter = new ImageConverter();
string base64 = Convert.ToBase64String((byte[])converter.ConvertTo(bitmap, typeof(byte[])));
```

## Json
基本的には`System.Json.Text.JsonSerializer`を使用する。
`JsonSerializer`を使用するためにはJsonのデータを表現するデータ型クラスが必要となる。

### データ型クラス
Jsonのキー名とAccessorのキー名を一致させると手間が掛からない。

```json
{
  "person": {
    "name": "yamada",
    "age": 20
  }
}
```

というJsonファイルなのであればデータ型クラスは

```C#
class Data {
  public Person person { get; set; }
}

class Person {
  public string name { get; set; }
  public int age { get; set; }
}
```

となる。
ただ、コーディング規約的にJsonやクラスのキー名が一致しない場合は下記のいずれかの対応を行う。

#### Camel、Pascalの差の場合
Jsonのキー名はキャメルケース、クラスはパスカルケースとしたい場合、シリアライズ時にオプションを指定することで解決する。

```C#
data = JsonSerializer.Deserialize<XBooksData>(jsonString, new JsonSerializerOptions {
  PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
});
```

#### 全く異なる場合
データ型に属性を付与することで解決する。

```C#
class Person {
  [JsonPropertyName("name")] // ←属性
  public string fullName { get; set; }
  public int age { get; set; }
}
```

### 読み込み
`JsonSerializer.Deserialize`を使用する。

```C#
JsonSerializer.Deserialize<Data>(jsonString);
```

### 書き込み
`JsonSerializer.Serialize`を使用する。

```C#
string jsonString = JsonSerializer.Serialize(data);
```

もしインデントが必要なのであればオプションで指定する。

```C#
string jsonString = JsonSerializer.Serialize(data, new JsonSerializerOptions {
  WriteIndented = true 
});
```


### `JsonSeralizer`を使用しない場合
`System.Json.Text.Nodes.JsonNode`を使用して地道に変換する。

```C#
using System.Json.Text.Nodes;

var jsonString = @"{key: value}";
JsonNode root = JsonNode.Parse(jsonString);
string value = (string)root["key"];
```

## データとコントロールの紐づけ
`System.Windows.Forms.BindingSource`を使用すると便利かも？
Web上では`DataGridView`でのサンプルばかりだったので、それ以外で使うのは適切でないのかもしれない。

```C#
public class Form1 : Form {
  private BindingSource _bindingSource;

  public Form1() {
    InitializeComponent();
    this._bindingSource = new BindingSource();
    this._bindingSource.DataSource = new Data();
    // Add(コントロールのプロパティ, 紐づけるデータ, データのプロパティ)
    this.label1.DataBindings.Add("Text", this._bindingSource, "Name");
  }
}

public class Data {
  public string Name { get; set; }
}
```

ただし、上記の実装では`Data.Name`が更新されたとしても、UIは更新されないので下記のいずれかの対応を行う。

### `BindingSource.ResetBindings(bool)`を呼び出す
紐づけられているデータが更新された後に、`System.Windows.Forms.BindingSource.ResetBindings(bool)`を呼び出すとUIも更新される。

```C#
data.name = "update";
this._bindingSource.ResetBindings(false);
```

引数はデータ構造が変わったら`true`、変わらないなら`false`らしい。`true`は処理重いらしいので、基本的には`false`を使いたい。

### `INotifyPropertyChanged`を実装する
紐づけられるデータクラスに`System.ConponentModel.INotifyPropertyChanged`を実装する。
`INotifyPropertyChanged`は値の更新を知らせるインターフェース。
データクラスの実装が面倒になるが、いちいち`ResetBindings`を呼び出さずに済むので楽。

```C#
public class Data : INotifyPropertyChanged {

  public event PropertyChangedEventHandler PropertyChanged;

  private void NotifyPropertyChanged([CallerMemberName] string propertyName = "") {
    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
  }

  private string _name;
  public int Name {
    get { return this._name; }
    set {
      if (this._name != value) {
        this._name = value;
        this.NotifyPropertyChanged();
        // nameが変わったことで他のプロパティに変化がある場合は一緒にイベントを発生させてもよい
        // this.NotifyPropertyChanged("fullName"); // フルネームも更新されたことを知らせる
      }
    }
  }
}
```